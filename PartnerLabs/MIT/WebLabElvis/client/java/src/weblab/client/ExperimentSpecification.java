package weblab.client;

// JAVA 1.1 COMPLIANT

import java.math.BigDecimal;
import java.util.Vector;
import java.util.Enumeration;

import weblab.xml.Parser;
import weblab.xml.Element;
import weblab.xml.InvalidXMLException;

import weblab.util.EngMath;


/**
 * Describes an experiment to be run on the lab server.
 * ExperimentSpecifications are generated by the client, taking into
 * account the information in the lab configuration.  An
 * ExperimentSpecification has a name (relevant only to saving and
 * loading), a reference to an experiment setup on which the experiment is to be
 * run (which is allowed to be null sometimes, for convenience), a
 * list of Instruments and a list of UserDefinedFunctions (UDFs).
 */
public class ExperimentSpecification
  extends weblab.util.ChangeTrackingObservable
{
  /**
   * Flag value to inform Observers that the Setup associated with
   * this has changed.
   */
  public static final String SETUP_CHANGE = "setup";

  /**
   * Flag value to inform Observers that the list of Instruments associated
   * with this has changed.
   *
   * Note: INSTRUMENTS_CHANGE can never occur without SETUP_CHANGE
   */
  public static final String INSTRUMENTS_CHANGE = "instruments";

  /**
   * URL to use for the Experiment Specification DTD.  This value may
   * need to be changed based on an applet parameter.
   */
  public static String dtd_url =
    "http://olid.mit.edu/xml/experimentSpecification.dtd";


  private String name;

  // Note: theSetup can be null, allowing an ExperimentSpecification to
  // exist independently of any setup!
  private Setup theSetup;

  private Vector instruments; // contains Instruments

  private Vector udfs; //contains UserDefinedFunction
  private Vector udfNames; // contains String.  This is a parallel
                           // vector to udfs; it makes it easier to
                           // find the udf with a particular name

  /**
   * Constructs a new ExperimentSpecification with the given name, no
   * instruments or UDFs, and no Setup.
   *
   * Note: you will generally want to call setSetup on the new
   * ExperimentSpecification immediately after construction.
   */
  public ExperimentSpecification(String name)
  {
    this.name = name;
    theSetup = null;
    instruments = new Vector();
    udfs = new Vector();
    udfNames = new Vector();
  }



  /**
   * Returns the name of this.
   */
  public final String getName()
  {
    return name;
  }



  /**
   * Sets the name of this.
   */
  public final void setName(String newName)
  {
    if (! newName.equals(this.name))
    {
      this.name = newName;
      this.setChanged();
    }
  }



  /**
   * Returns the Setup associated with this.
   */
  public final Setup getSetup()
  {
    return theSetup;
  }



  /**
   * Determines whether this ExperimentSpecification is compatible
   * with newSetup.  The significance of "compatibility" is that it
   * implies that calling setSetup(newSetup) will not result in the
   * loss of any useful information (that is to say, it will not cause
   * any configured Instruments to be discarded).
   *
   * @return true iff every Instrument in this either (a) is used by
   * newSetup or (b) is not configured, as defined by the return
   * value of Instrument.isConfigured()
   */
  public final boolean checkSetupCompatibility(Setup newSetup)
  {
    // any ExperimentSpecification is compatible with the null setup,
    // as setSetup(null) does not discard any Instruments.
    if (newSetup == null)
      return true;

    // willBeUsed is a parallel array to this.instruments; each element
    // indicates whether its corresponding instrument is used by the new
    // setup
    boolean[] willBeUsed = new boolean[instruments.size()];

    // look at terminals of new setup, fill in appropriate true
    // values in willBeUsed
    Terminal[] terms = newSetup.getTerminals();
    for (int i = 0; i < terms.length; i++)
    {
      int instrumentType = terms[i].getInstrumentType();
      int instrumentNumber = terms[i].getInstrumentNumber();
      int instrumentIndex = this.indexOfInstrument(instrumentType, instrumentNumber);
      if (instrumentIndex != -1)
    	  willBeUsed[instrumentIndex] = true;
    }

    // if any configured instrument in this is not used by the new setup,
    // then the new setup is not compatible
    for (int i = 0; i < instruments.size(); i++)
    {
      if (! willBeUsed[i] && ((Instrument) instruments.elementAt(i)).isConfigured())
    	  return false;
    }

    // if we get here, the new setup is compatible
    return true;
  }



  /**
   * Changes the setup associated with this to newSetup.  Updates
   * the instruments of this to reflect those needed by the new setup,
   * throwing away any instruments which are not used by the new setup
   * (UNLESS newSetup is null, in which case all of the instruments are
   * left alone).
   */
  public final void setSetup(Setup newSetup)
  {
    if (newSetup == null)
    {
      if (theSetup != null)
      {
    	  theSetup = null;
    	  this.setChanged(SETUP_CHANGE);

			// make sure all instruments are no longer connected to a terminal
			for (int i = 0; i < instruments.size(); i++)
			{
			  Instrument s = (Instrument) instruments.elementAt(i);
			  s.setTerminal(null);
			  s.notifyObservers();
			}
      }
    }
    else if (! newSetup.equals(this.theSetup))
    {
      this.theSetup = newSetup;

      Vector newInstruments = new Vector();
      Terminal[] terms = newSetup.getTerminals();
      for (int i = 0; i < terms.length; i++)
      {
    	  int instrumentType = terms[i].getInstrumentType();
    	  int instrumentNumber = terms[i].getInstrumentNumber();
    	  // See if we already have the instrument we need.  If not, create a
    	  // new one.  In either case, add it to our new instrument list.
    	  Instrument nextInstrument = this.findInstrument(instrumentType, instrumentNumber);
    	  if (nextInstrument == null)
    		  nextInstrument = Instrument.createInstrument(instrumentType, instrumentNumber);
    	  	  newInstruments.addElement(nextInstrument);
    	  	  // make sure the instrument is connected to its terminal
    	  	  nextInstrument.setTerminal(terms[i]);
    	  	  nextInstrument.notifyObservers();
      	  }
      	  this.instruments = newInstruments;
          this.setChanged(SETUP_CHANGE);
          this.setChanged(INSTRUMENTS_CHANGE);
    }
  }



  /**
   * Returns an Enumeration of the Instruments associated with this.
   *
   * @return Enumeration of Instrument
   */
  public final Enumeration getInstruments()
  {
    return instruments.elements();
  }



  /**
   * Returns an Instrument associated with this that has the specified
   * instrumentType and instrumentNumber, or null if there is no such instrument
   * associated with this.
   */
  public final Instrument findInstrument(int instrumentType, int instrumentNumber)
  {
    int i = indexOfInstrument(instrumentType, instrumentNumber);
    if (i == -1)
      return null;
    else
      return (Instrument) instruments.elementAt(i);
  }



  // helper method.  Returns -1 if DNE
  private int indexOfInstrument(int instrumentType, int instrumentNumber)
  {
    for (int i = 0; i < instruments.size(); i++)
    {
      Instrument nextInstrument = (Instrument) instruments.elementAt(i);
      if (nextInstrument.getType() == instrumentType &&
	      nextInstrument.getNumber() == instrumentNumber)
    	  return i;
    }
    // not found
    return -1;
  }



  /**
   * Returns an enumeration of the UserDefinedFunctions currently in
   * this.
   *
   * @return Enumeration of UserDefinedFunction
   */
  public final Enumeration getUserDefinedFunctions()
  {
    return udfs.elements();
  }



  /**
   * Returns an enumeration of the names of the UDFs currently in this.
   *
   * @return Enumeration of String
   */
  public final Enumeration getUserDefinedFunctionNames()
  {
    return udfNames.elements();
  }



  /**
   * Adds a UserDefinedFunction to this.  If a UDF with the same name
   * as <code>f</code> already exists in this, the existing UDF will
   * be overwritten.
   */
  public final void addUserDefinedFunction(UserDefinedFunction f)
  {
    String name = f.getName();

    // find index of existing UDF with same name, if any
    int i = udfNames.indexOf(name);
    if (i == -1)
    {
      // name not used yet, add this UDF as new
      udfs.addElement(f);
      udfNames.addElement(name);
      this.setChanged();
    }
    else
    {
      // name already exists; overwrite if f is different from current value
      if (! f.equals(udfs.elementAt(i)))
      {
    	  udfs.setElementAt(f, i);
    	  udfNames.setElementAt(name, i);
    	  this.setChanged();
      }
    }
  }



  /**
   * Removes the UDF with the specified name from this.  If no such
   * UDF exists, does nothing.
   */
  public final void removeUserDefinedFunction(String name)
  {
    int i = udfNames.indexOf(name);
    if (i != -1)
    {
      udfs.removeElementAt(i);
      udfNames.removeElementAt(i);
      this.setChanged();
    }
  }



  /**
   * Removes all UDFs from this.
   */
  public final void removeAllUserDefinedFunctions()
  {
    if (! udfs.isEmpty())
    {
      udfs.removeAllElements();
      udfNames.removeAllElements();
      this.setChanged();
    }
  }



  /**
   * Generates a new ExperimentSpecification from the specified XML
   * string (which was presumably previously written by the client and
   * saved on the service broker).  The new ExperimentSpecification is
   * given a blank name ("") and no Setup.
   *
   * Note: you will generally want to call setSetup and/or setName on
   * the new ExperimentSpecification immediately after construction.
   */
  public final static ExperimentSpecification
    parseXMLExperimentSpecification(String xmlString)
    throws InvalidExperimentSpecificationException
  {
    ExperimentSpecification e = new ExperimentSpecification("");

    Element xmlExperimentSpecification;

    try {
      xmlExperimentSpecification = Parser.parse(xmlString);
    }
    catch (InvalidXMLException ex) {
      throw new InvalidExperimentSpecificationException
	(ex.getMessage());
    }


    if (! xmlExperimentSpecification.getName().equals
	("experimentSpecification"))
    {
      throw new InvalidExperimentSpecificationException
	("illegal root element " + xmlExperimentSpecification.getName());
    }

    // terminal ...
    //
    Enumeration enum_terms =
      xmlExperimentSpecification.getChildren("terminal");
    while (enum_terms.hasMoreElements())
    {
      Element xmlTerminal = (Element) enum_terms.nextElement();

      // instrumentNumber=
      int instrumentNumber = Integer.parseInt
	(xmlTerminal.getAttributeValue("instrumentNumber"));

      String instrumentTypeName = xmlTerminal.getAttributeValue("instrumentType");
      if (instrumentTypeName.equals("FGEN"))
      {
    	  FGEN newFGEN = new FGEN(instrumentNumber);

    	  // vname, download
    	  Element xmlVname = xmlTerminal.getChild("vname");
    	  newFGEN.setVName(xmlVname.getData());
    	  newFGEN.setVDownload(Boolean.valueOf(xmlVname.getAttributeValue("download")).booleanValue());

    	  // function
    	  Element xmlFunction = (Element) xmlTerminal.getChild("function");
    	  SourceFunction f = extractXMLFunction(xmlFunction);
    	  newFGEN.setFunction(f);

    	  e.instruments.addElement(newFGEN);
      }else if (instrumentTypeName.equals("SCOPE"))
      {
    	  SCOPE newSCOPE = new SCOPE(instrumentNumber);

    	  // vname, download
    	  Element xmlVname = xmlTerminal.getChild("vname");
    	  newSCOPE.setVName(xmlVname.getData());
    	  newSCOPE.setVDownload(Boolean.valueOf(xmlVname.getAttributeValue("download")).booleanValue());

    	  // function
    	  Element xmlFunction = (Element) xmlTerminal.getChild("function");
    	  SourceFunction f = extractXMLFunction(xmlFunction);
    	  newSCOPE.setFunction(f);

    	  e.instruments.addElement(newSCOPE);
      }
      else {
    	  throw new InvalidExperimentSpecificationException("illegal instrument type: " + instrumentTypeName);
      }
    }

    // userDefinedFunction ...
    //
    Enumeration enum_udfs = 
      xmlExperimentSpecification.getChildren("userDefinedFunction");
    while (enum_udfs.hasMoreElements())
    {
      Element xmlUserDefinedFunction = (Element) enum_udfs.nextElement();

      // name
      String name;
      Element xmlName = xmlUserDefinedFunction.getChild("name");
      name = xmlName.getData();

      // download
      boolean download = Boolean.valueOf(xmlName.getAttributeValue("download")).booleanValue();

      // units
      String units = xmlUserDefinedFunction.getChild("units").getData();

      // body
      String body = xmlUserDefinedFunction.getChild("body").getData();

      e.addUserDefinedFunction(new UserDefinedFunction(name, download, units, body));
    }

    return e;
  }



  /**
   * Returns an XML-encoded representation of this, suitable for
   * submitting to the lab server for execution (or saving on the
   * service broker for subsequent retrieval).
   *
   * Note: if there is currently no setup associated with this,
   * toXMLString will simply omit the setupID tag from its output.
   */
  public final String toXMLString()
  {
    // start with an empty buffer
    StringBuffer sb = new StringBuffer();

    // write XML preamble
    sb.append("<?xml version=\"1.0\" encoding=\"utf-8\" standalone=\"no\" ?>\n<!DOCTYPE experimentSpecification SYSTEM \"" + dtd_url + "\">");

    // write XML tags using a helper Visitor object
    this.accept(new ToXMLVisitor(sb));

    return sb.toString();
  }



  // helper method for parseXMLExperimentSpecification
  private static SourceFunction extractXMLFunction(Element xmlFunction)
    throws InvalidExperimentSpecificationException
  {    
    String typeName = xmlFunction.getAttributeValue("type");
    if (typeName.equals("WAVEFORM"))
    {
      // waveformType
      String strWaveformType = xmlFunction.getChild("waveformType").getData();
      int waveformType = 0;
      if (strWaveformType.equals("SINE")){
    	  waveformType = WAVEFORMFunction.SINE_WAVE;
      }else if (strWaveformType.equals("SQUARE")){
    	  waveformType = WAVEFORMFunction.SQUARE_WAVE;
      }else if (strWaveformType.equals("TRIANGULAR")){
    	  waveformType = WAVEFORMFunction.TRIANGULAR_WAVE;
      }else{
    	  throw new InvalidExperimentSpecificationException("illegal waveform Type: " + strWaveformType);
      }
    	  
      BigDecimal frequency = EngMath.parseBigDecimal(xmlFunction.getChild("frequency").getData());
      BigDecimal amplitude = EngMath.parseBigDecimal(xmlFunction.getChild("amplitude").getData());
      BigDecimal offset = EngMath.parseBigDecimal(xmlFunction.getChild("offset").getData());

      return new WAVEFORMFunction(waveformType, frequency, amplitude, offset);
    }
    else if (typeName.equals("SAMPLING"))
    {
        // waveformType
        BigDecimal rate = EngMath.parseBigDecimal(xmlFunction.getChild("samplingRate").getData());
        BigDecimal time = EngMath.parseBigDecimal(xmlFunction.getChild("samplingTime").getData());
        
        return new SAMPLINGFunction(rate, time);
      }
    
    else if (typeName.equals("VAR1"))
    {
      // scale
      int scale;
      String scaleName = xmlFunction.getChild("scale").getData();
      if (scaleName.equals("LIN"))
    	  scale = VAR1Function.LIN_SCALE;
      else if (scaleName.equals("LOG10"))
    	  scale = VAR1Function.LOG10_SCALE;
      else if (scaleName.equals("LOG25"))
    	  scale = VAR1Function.LOG25_SCALE;
      else if (scaleName.equals("LOG50"))
    	  scale = VAR1Function.LOG50_SCALE;
      else {
    	  throw new InvalidExperimentSpecificationException("illegal scale: " + scaleName);
      }

      // start
      BigDecimal start = EngMath.parseBigDecimal(xmlFunction.getChild("start").getData());

      // stop
      BigDecimal stop = EngMath.parseBigDecimal(xmlFunction.getChild("stop").getData());

      // step (LIN scale only)
      BigDecimal step;
      if (scale == VAR1Function.LIN_SCALE)
    	  step = EngMath.parseBigDecimal(xmlFunction.getChild("step").getData());
      else
    	  step = null;

      return new VAR1Function(scale, start, stop, step);      
    }
    else if (typeName.equals("VAR2"))
    {
      // start
      BigDecimal start = EngMath.parseBigDecimal
	(xmlFunction.getChild("start").getData());

      // stop
      BigDecimal stop = EngMath.parseBigDecimal
	(xmlFunction.getChild("stop").getData());

      // step
      BigDecimal step = EngMath.parseBigDecimal
	(xmlFunction.getChild("step").getData());

      return new VAR2Function(start, stop, step);
    }
    else if (typeName.equals("VAR1P"))
    {
      // ratio
      BigDecimal ratio = EngMath.parseBigDecimal
	(xmlFunction.getChild("ratio").getData());

      // offset
      BigDecimal offset = EngMath.parseBigDecimal
	(xmlFunction.getChild("offset").getData());

      return new VAR1PFunction(ratio, offset);
    }
    else {
      throw new InvalidExperimentSpecificationException
	("illegal source function type: " + typeName);
    }
  }



  // helper class for toXMLString
  private static class ToXMLVisitor extends DefaultVisitor
  {
    // StringBuffer to write XML into
    private StringBuffer sb;

    public ToXMLVisitor(StringBuffer sb)
    {
      this.sb = sb;
    }

    public final void visitExperimentSpecification(ExperimentSpecification e)
    {
      // begin experimentSpecification
      sb.append("<experimentSpecification " +
		"lab=\"MIT NI-ELVIS Weblab\" specversion=\"0.1\">");

      // setupID (if any)
      if (e.getSetup() != null)
      {
    	  sb.append("<setupID>" + e.getSetup().getSetupID() + "</setupID>");
      }

      // visit Instruments
      Enumeration instrument_enum = e.getInstruments();
      while (instrument_enum.hasMoreElements())
      {
    	  Instrument nextInstrument = (Instrument) instrument_enum.nextElement();
    	  nextInstrument.accept(this);
      }

      // visit UDFs
      Enumeration udf_enum = e.getUserDefinedFunctions();
      while (udf_enum.hasMoreElements())
      {
    	  UserDefinedFunction udf = (UserDefinedFunction) udf_enum.nextElement();
    	  udf.accept(this);
      }

      // end experimentSpecification
      sb.append("</experimentSpecification>");
    }

    
    public final void visitFGEN(FGEN f)
    {
      // begin terminal
      sb.append("<terminal instrumentType=\"FGEN\" instrumentNumber=\"");
      sb.append(f.getNumber());
      sb.append("\">");

      // vname
      if (f.getVDownload())
    	  sb.append("<vname download=\"true\">");
      else
    	  sb.append("<vname download=\"false\">");
      	  sb.append(f.getVName());
      	  sb.append("</vname>");

      // function
      f.getFunction().accept(this);

      // end terminal
      sb.append("</terminal>");
    }

    public final void visitSCOPE(SCOPE s)
    {
      // begin terminal
      sb.append("<terminal instrumentType=\"SCOPE\" instrumentNumber=\"");
      sb.append(s.getNumber());
      sb.append("\">");

      // vname
      if (s.getVDownload())
    	  sb.append("<vname download=\"true\">");
      else
    	  sb.append("<vname download=\"false\">");
      	  sb.append(s.getVName());
      	  sb.append("</vname>");

      // function
      s.getFunction().accept(this);

      // end terminal
      sb.append("</terminal>");
    }
    
    public final void visitCONSFunction(CONSFunction f)
    {
      sb.append("<function type=\"CONS\">");

      sb.append("<value>");
      sb.append(f.getValue());
      sb.append("</value>");

      sb.append("</function>");
    }

    public final void visitWAVEFORMFunction(WAVEFORMFunction f)
    {
      sb.append("<function type=\"WAVEFORM\">");

      sb.append("<waveformType>");
      if (f.getWaveformType() == WAVEFORMFunction.SINE_WAVE){
    	  sb.append("SINE");  
      }else if (f.getWaveformType() == WAVEFORMFunction.SQUARE_WAVE){
    	  sb.append("SQUARE");
      }else if (f.getWaveformType() == WAVEFORMFunction.TRIANGULAR_WAVE){
    	  sb.append("TRIANGULAR");
      }
      sb.append("</waveformType>");
      sb.append("<frequency>");
      sb.append(f.getFrequency());
      sb.append("</frequency>");
      sb.append("<amplitude>");
      sb.append(f.getAmplitude());
      sb.append("</amplitude>");
      sb.append("<offset>");
      sb.append(f.getOffset());
      sb.append("</offset>");
      sb.append("</function>");
    }

    public final void visitSAMPLINGFunction(SAMPLINGFunction f)
    {
      sb.append("<function type=\"SAMPLING\">");

      sb.append("<samplingRate>");
      sb.append(f.getRate());
      sb.append("</samplingRate>");
      sb.append("<samplingTime>");
      sb.append(f.getTime());
      sb.append("</samplingTime>");
      sb.append("</function>");
    }
    
    public final void visitVAR1Function(VAR1Function f)
    {
      sb.append("<function type=\"VAR1\">");

      switch(f.getScale())
      {
      case VAR1Function.LIN_SCALE:
	sb.append("<scale>LIN</scale>");
	break;
      case VAR1Function.LOG10_SCALE:
	sb.append("<scale>LOG10</scale>");
	break;
      case VAR1Function.LOG25_SCALE:
	sb.append("<scale>LOG25</scale>");
	break;
      case VAR1Function.LOG50_SCALE:
	sb.append("<scale>LOG50</scale>");
	break;
      }

      sb.append("<start>");
      sb.append(f.getStart());
      sb.append("</start>");

      sb.append("<stop>");
      sb.append(f.getStop());
      sb.append("</stop>");

      if (f.getScale() == VAR1Function.LIN_SCALE)
      {
	sb.append("<step>");
	sb.append(f.getStep());
	sb.append("</step>");
      }

      sb.append("</function>");
    }

    public final void visitVAR2Function(VAR2Function f)
    {
      sb.append("<function type=\"VAR2\">");

      // always LIN scale
      sb.append("<scale>LIN</scale>");

      sb.append("<start>");
      sb.append(f.getStart());
      sb.append("</start>");

      sb.append("<stop>");
      sb.append(f.getStop());
      sb.append("</stop>");

      sb.append("<step>");
      sb.append(f.getStep());
      sb.append("</step>");

      sb.append("</function>");
    }

    public final void visitVAR1PFunction(VAR1PFunction f)
    {
      sb.append("<function type=\"VAR1P\">");

      sb.append("<ratio>");
      sb.append(f.getRatio());
      sb.append("</ratio>");

      sb.append("<offset>");
      sb.append(f.getOffset());
      sb.append("</offset>");

      sb.append("</function>");
    }

    public final void visitUserDefinedFunction(UserDefinedFunction udf)
    {
      // begin userDefinedFunction
      sb.append("<userDefinedFunction>");

      // name
      if (udf.getDownload())
	sb.append("<name download=\"true\">");
      else
	sb.append("<name download=\"false\">");
      sb.append(udf.getName());
      sb.append("</name>");

      // units
      sb.append("<units>");
      sb.append(udf.getUnits());
      sb.append("</units>");

      // body
      sb.append("<body>");
      sb.append(udf.getBody());
      sb.append("</body>");

      // end userDefinedFunction
      sb.append("</userDefinedFunction>");    
    }
  } // end inner class ToXMLVisitor



  /**
   * Accepts a Visitor, according to the Visitor design pattern.
   */
  public final void accept(Visitor v)
  {
    v.visitExperimentSpecification(this);
  }

} // end class ExperimentSpecification
