/*
 * Copyright (c) 2005 The Massachusetts Institute of Technology.  All
 * rights reserved.  Please see license.txt in top level directory for
 * full license.
 */

package weblab.client;

import java.math.BigDecimal;

import java.util.Collections;
import java.util.Collection;
import java.util.List;
import java.util.Iterator;
import java.util.ArrayList;

import weblab.toolkit.xml.Parser;
import weblab.toolkit.xml.Element;
import weblab.toolkit.xml.InvalidXMLException;

import weblab.toolkit.util.ChangeTrackingObservable;
import weblab.toolkit.util.EngMath;


/**
 * Describes an experiment to be run on the lab server.
 * ExperimentSpecifications are generated by the client, taking into
 * account the information in the lab configuration.  An
 * ExperimentSpecification has a name (relevant only to saving and
 * loading), a reference to a Device on which the experiment is to be
 * run (which is allowed to be null sometimes, for convenience), a
 * list of Ports specifying the setup of ports on the analyzer, and a
 * list of UserDefinedFunctions (UDFs).
 */
public class ExperimentSpecification extends ChangeTrackingObservable
  implements Cloneable
{
  /**
   * Flag value to inform Observers that the Device associated with
   * this has changed.
   */
  public static final String DEVICE_CHANGE = "device";

  /**
   * Flag value to inform Observers that the list of Ports associated
   * with this has changed.
   *
   * Note: PORTS_CHANGE can never occur without DEVICE_CHANGE
   */
  public static final String PORTS_CHANGE = "ports";

  // URL to use for ExperimentSpecification DTD (null to omit)
  private static String dtdURL = null;

  private String name;

  private boolean allowQuickSave;

  // Note: theDevice can be null, allowing an ExperimentSpecification to
  // exist independently of any device!
  private Device theDevice;

  private List ports; // contains Port
  private ArrayList udfs; // contains UserDefinedFunction


  /**
   * Constructs a new ExperimentSpecification with the given name, no
   * ports or UDFs, and no Device.
   *
   * Note: you will generally want to call setDevice on the new
   * ExperimentSpecification immediately after construction.
   */
  public ExperimentSpecification(String name)
  {
    this.name = name;
    theDevice = null;
    ports = new ArrayList();
    udfs = new ArrayList();
    this.allowQuickSave = false;
  }



  /**
   * Returns the name of this.
   */
  public final String getName()
  {
    return name;
  }



  /**
   * Sets the name of this.
   */
  public final void setName(String newName)
  {
    if (! newName.equals(this.name))
    {
      this.name = newName;
      this.setChanged();
    }
  }



  /**
   * Returns true iff this ExperimentSpecification is currently
   * considered quick-saveable, i.e. if the user should be allowed to
   * save it without being prompted to edit the name.
   */
  public final boolean isQuickSaveable()
  {
    return this.allowQuickSave;
  }



  /**
   * Sets whether this ExperimentSpecification should be considered
   * quick-saveable (see isQuickSaveable for explanation).
   */
  public final void setQuickSaveable(boolean allowQuickSave)
  {
    if (this.allowQuickSave != allowQuickSave)
    {
      this.allowQuickSave = allowQuickSave;
      this.setChanged();
    }
  }



  /**
   * Returns the Device associated with this.
   */
  public final Device getDevice()
  {
    return theDevice;
  }



  /**
   * Determines whether this ExperimentSpecification is compatible
   * with newDevice.  The significance of "compatibility" is that it
   * implies that calling setDevice(newDevice) will not result in the
   * loss of any useful information (that is to say, it will not cause
   * any configured Ports to be discarded).
   *
   * @return true iff every Port in this either (a) is used by
   * newDevice or (b) is not configured, as defined by the return
   * value of Port.isConfigured()
   */
  public final boolean checkDeviceCompatibility(Device newDevice)
  {
    // any ExperimentSpecification is compatible with the null device,
    // as setDevice(null) does not discard any Ports.
    if (newDevice == null)
      return true;

    // willBeUsed is a parallel array to this.ports; each element
    // indicates whether its corresponding port is used by the new
    // device
    boolean[] willBeUsed = new boolean[ports.size()];

    // look at terminals of new device, fill in appropriate true
    // values in willBeUsed
    List terms = newDevice.getTerminals();
    for (int i = 0, n = terms.size(); i < n; i++)
    {
      Terminal t = (Terminal) terms.get(i);
      int portIndex = this.indexOfPort(t.getPortType(), t.getPortNumber());
      if (portIndex != -1)
	willBeUsed[portIndex] = true;
    }

    // if any configured port in this is not used by the new device,
    // then the new device is not compatible
    for (int i = 0, n = ports.size(); i < n; i++)
    {
      if (! willBeUsed[i] && ((Port) ports.get(i)).isConfigured())
	return false;
    }

    // if we get here, the new device is compatible
    return true;
  }



  /**
   * Changes the device associated with this to newDevice.  Updates
   * the ports of this to reflect those needed by the new device,
   * throwing away any ports which are not used by the new device
   * (UNLESS newDevice is null, in which case all of the ports are
   * left alone).
   */
  public final void setDevice(Device newDevice)
  {
    if (newDevice == null)
    {
      if (theDevice != null)
      {
	theDevice = null;
	this.setChanged(DEVICE_CHANGE);

	// make sure all ports are no longer connected to a terminal
	for (int i = 0, n = ports.size(); i < n; i++)
	{
	  Port p = (Port) ports.get(i);
	  p.setTerminal(null);
	  p.notifyObservers();
	}
      }
    }
    else if (! newDevice.equals(this.theDevice))
    {
      this.theDevice = newDevice;

      List terms = newDevice.getTerminals();
      List newPorts = new ArrayList();

      for (int i = 0, n = terms.size(); i < n; i++)
      {
	Terminal t = (Terminal) terms.get(i);
	int portType = t.getPortType();
	int portNumber = t.getPortNumber();

	// See if we already have the port we need.  If not, create a
	// new one.  In either case, add the port to our new list.
	Port nextPort = this.findPort(portType, portNumber);
	if (nextPort == null)
	  nextPort = Port.createPort(portType, portNumber);
	newPorts.add(nextPort);

	// make sure the port is connected to its new terminal
	nextPort.setTerminal(t);
	nextPort.notifyObservers();
      }

      this.ports = newPorts;
      this.setChanged(DEVICE_CHANGE);
      this.setChanged(PORTS_CHANGE);
    }
  }



  /**
   * Returns a read-only Iterator over the Ports of this.
   *
   * @return Iterator of Port
   */
  public final Iterator getPorts()
  {
    return Collections.unmodifiableList(ports).iterator();
  }



  /**
   * Returns a Port associated with this that has the specified
   * portType and portNumber, or null if there is no such port
   * associated with this.
   */
  public final Port findPort(int portType, int portNumber)
  {
    int i = indexOfPort(portType, portNumber);
    if (i == -1)
      return null;
    else
      return (Port) ports.get(i);
  }



  // helper method.  Returns -1 if DNE
  private int indexOfPort(int portType, int portNumber)
  {
    for (int i = 0, n = ports.size(); i < n; i++)
    {
      Port nextPort = (Port) ports.get(i);
      if (nextPort.getType() == portType &&
	  nextPort.getNumber() == portNumber)
	return i;
    }

    // not found
    return -1;
  }



  /**
   * Returns a read-only Iterator over the UserDefinedFunctions
   * currently in this.
   *
   * @return Iterator of UserDefinedFunction
   */
  public final Iterator getUserDefinedFunctions()
  {
    return Collections.unmodifiableList(udfs).iterator();
  }



  /**
   * Adds a UserDefinedFunction to this.  If a UDF with the same name
   * as <code>f</code> already exists in this, the existing UDF will
   * be overwritten.
   */
  public final void addUserDefinedFunction(UserDefinedFunction f)
  {
    // find index of existing UDF with same name, if any
    int i = indexOfUDF(f.getName());

    if (i == -1)
    {
      // name not in use, add this UDF as new
      udfs.add(f);
      this.setChanged();
    }
    else
    {
      // name already in use; overwrite if f is different from the
      // current UDF with this name
      if (! f.equals(udfs.get(i)))
      {
	udfs.set(i, f);
	this.setChanged();
      }
    }
  }



  /**
   * Removes the UDF with the specified name from this.  If no such
   * UDF exists, does nothing.
   */
  public final void removeUserDefinedFunction(String name)
  {
    // find index of existing UDF with same name, if any
    int i = indexOfUDF(name);

    if (i != -1)
    {
      udfs.remove(i);
      this.setChanged();
    }
  }



  /**
   * Removes all UDFs from this.
   */
  public final void clearUserDefinedFunctions()
  {
    if (! udfs.isEmpty())
    {
      udfs.clear();
      this.setChanged();
    }
  }



  /**
   * Resets the UDFs of this to those in the specified Collection (by
   * adding all UDFs in <code>c</code> that are not already present in
   * this, and removing all UDFs in this that are not present in
   * <code>c</code>).  Keep in mind that an ExperimentSpecification
   * can never contain two UDFs with the same name; if <code>c</code>
   * contains such, only one of them will end up in the UDFs of this.
   *
   * requires: <code>c</code> contains only UserDefinedFunctions
   */
  public void setUserDefinedFunctions(Collection c)
  {
    // add all UDFs in c to this using addUserDefinedFunction (will
    // automatically handle issues with duplicate names, adding things
    // that already exist, etc)
    for (Iterator i = c.iterator(); i.hasNext(); )
    {
      UserDefinedFunction u = (UserDefinedFunction) i.next();

      // will call this.setChanged() if appropriate
      this.addUserDefinedFunction(u);
    }

    // remove all existing UDFs not equals() to any UDF in c
    boolean changeFlag = udfs.retainAll(c);

    if (changeFlag)
      this.setChanged();
  }



  /**
   * Sets a URL that the toXMLString() method will use to refer to the
   * Experiment Specification DTD.  Setting the dtdUrl to null will
   * cause toXMLString() to completely omit the document type
   * declaration.
   */
  public static void setDTD(String dtdUrl)
  {
    ExperimentSpecification.dtdURL = dtdUrl;
  }



  /**
   * Generates a new ExperimentSpecification from the specified XML
   * string (which was presumably previously written by the client and
   * saved on the service broker).
   *
   * If a LabConfiguration is provided and xmlString contains a
   * deviceID tag, attempts to find a Device with this deviceID in the
   * LabConfiguration and select that Device for the new
   * ExperimentSpecification.  No compatibility checking is performed
   * here; if the specification configures ports which are not used by
   * this Device, that information will be lost when the Device is
   * selected.  If lc is null, or xmlString does not contain a
   * deviceID tag, or lc does not contain a device with the
   * appropriate deviceID, then the new ExperimentSpecification will
   * have a null Device (and is guaranteed not to lose any port
   * configuration information).
   *
   * The new ExperimentSpecification is given a blank name ("").
   *
   * Note: you will often want to call setDevice and/or setName on the
   * new ExperimentSpecification immediately after construction.
   *
   * @param xmlString the XML representation of the Experiment Specification
   * @param lc the LabConfiguration from which to attempt to select a
   * device if xmlString contains a <deviceID> tag, or null
   */
  public final static ExperimentSpecification
    parseXMLExperimentSpecification(String xmlString, LabConfiguration lc)
    throws InvalidExperimentSpecificationException
  {
    Element xmlExperimentSpecification;

    // parse XML and make sure the root element is experimentSpecification
    try
    {
      xmlExperimentSpecification = Parser.parse(xmlString);

      if (! xmlExperimentSpecification.getName()
	  .equals("experimentSpecification"))
	throw new InvalidExperimentSpecificationException
	  ("illegal root element " + xmlExperimentSpecification.getName());
    }
    catch (InvalidXMLException ex) {
      throw new InvalidExperimentSpecificationException(ex);
    }

    // construct ExperimentSpecification based on XML content
    try
    {
      ExperimentSpecification es = new ExperimentSpecification("");

      // read <terminal portType='X' portNumber='N'> ... and generate
      // Port objects
      for (Iterator i = xmlExperimentSpecification.getChildren("terminal")
	     .iterator();
	   i.hasNext(); )
      {
	Element xmlTerminal = (Element) i.next();

	int portNumber = Integer.parseInt
	  (xmlTerminal.getRequiredAttributeValue("portNumber"));

	String portTypeName =
	  xmlTerminal.getRequiredAttributeValue("portType");

	if (portTypeName.equals("SMU"))
	{
	  SMU newSMU = new SMU(portNumber);

	  // read <vname download='B'>X</vname>
	  Element xmlVname = xmlTerminal.getRequiredChild("vname");
	  newSMU.setVName(xmlVname.getData());
	  newSMU.setVDownload
	    (Boolean.valueOf(xmlVname.getRequiredAttributeValue("download"))
	     .booleanValue());

	  // read <iname download='B'>X</iname>
	  Element xmlIname = xmlTerminal.getRequiredChild("iname");
	  newSMU.setIName(xmlIname.getData());
	  newSMU.setIDownload
	    (Boolean.valueOf(xmlIname.getRequiredAttributeValue("download"))
	     .booleanValue());

	  // read <mode>X</mode>
	  int mode;
	  String modeName =
	    xmlTerminal.getRequiredChild("mode").getRequiredData();
	  if (modeName.equals("V"))
	    mode = SMU.V_MODE;
	  else if (modeName.equals("I"))
	    mode = SMU.I_MODE;
	  else if (modeName.equals("COMM"))
	    mode = SMU.COMM_MODE;
	  else {
	    throw new InvalidExperimentSpecificationException
	      ("illegal mode: " + modeName);
	  }
	  newSMU.setMode(mode);

	  if (mode != SMU.COMM_MODE)
	  {
	    // read source function
	    Element xmlFunction = xmlTerminal.getRequiredChild("function");
	    SourceFunction f = readXMLSourceFunction(xmlFunction);
	    newSMU.setFunction(f);

	    // read <compliance>N</compliance>
	    BigDecimal compliance = EngMath.parseBigDecimal
	      (xmlTerminal.getRequiredChild("compliance").getRequiredData());
	    newSMU.setCompliance(compliance);
	  }

	  // ... </terminal>
	  es.ports.add(newSMU);
	}
	else if (portTypeName.equals("VSU"))
	{
	  VSU newVSU = new VSU(portNumber);

	  // read <vname download='B'>X</vname>
	  Element xmlVname = xmlTerminal.getRequiredChild("vname");
	  newVSU.setVName(xmlVname.getData());
	  newVSU.setVDownload
	    (Boolean.valueOf(xmlVname.getRequiredAttributeValue("download"))
	     .booleanValue());

	  // read source function
	  Element xmlFunction = xmlTerminal.getRequiredChild("function");
	  SourceFunction f = readXMLSourceFunction(xmlFunction);
	  newVSU.setFunction(f);

	  // ... </terminal>
	  es.ports.add(newVSU);
	}
	else if (portTypeName.equals("VMU"))
	{
	  VMU newVMU = new VMU(portNumber);

	  // read <vname download='B'>X</vname>
	  Element xmlVname = xmlTerminal.getRequiredChild("vname");
	  newVMU.setVName(xmlVname.getData());
	  newVMU.setVDownload
	    (Boolean.valueOf(xmlVname.getRequiredAttributeValue("download"))
	     .booleanValue());

	  // (don't bother reading mode; we only support V_MODE)

	  // ... </terminal>
	  es.ports.add(newVMU);
	}
	else {
	  throw new InvalidExperimentSpecificationException
	    ("illegal port type: " + portTypeName);
	}
      }

      // read <userDefinedFunction> ... and generate
      // UserDefinedFunction objects
      for (Iterator i =
	     xmlExperimentSpecification.getChildren("userDefinedFunction")
	     .iterator();
	   i.hasNext(); )
      {
	Element xmlUserDefinedFunction = (Element) i.next();

	// read <name download='B'>X</name>
	Element xmlName = xmlUserDefinedFunction.getRequiredChild("name");

	String name = xmlName.getRequiredData();

	boolean download =
	  Boolean.valueOf(xmlName.getRequiredAttributeValue("download"))
	  .booleanValue();

	// read <units>X</units>
	String units =
	  xmlUserDefinedFunction.getRequiredChild("units").getData();

	// read <body>X</body>
	String body =
	  xmlUserDefinedFunction.getRequiredChild("body").getData();

	// ... </userDefinedFunction>
	es.addUserDefinedFunction
	  (new UserDefinedFunction(name, download, units, body));
      }

      // read optional <deviceID>N</deviceID>
      Element xmlDeviceID = xmlExperimentSpecification.getChild("deviceID");
      if (xmlDeviceID != null && lc != null)
      {
	int deviceID = Integer.parseInt
	  (xmlDeviceID.getRequiredData());

	// if lc contains a device with this deviceID, select it
	List devices = lc.getDevices();
	for (int i = 0, n = devices.size(); i < n; i++)
	{
	  Device d = (Device) devices.get(i);
	  if (d.getDeviceID() == deviceID)
	  {
	    es.setDevice(d);
	    break;
	  }
	}
      }

      return es;
    }
    catch (InvalidXMLException ex) {
      // it's not really invalid XML per se when this comes from
      // Element.getRequiredFOO, so just copy the message
      throw new InvalidExperimentSpecificationException(ex.getMessage());
    }
    catch (NumberFormatException ex) {
      throw new InvalidExperimentSpecificationException(ex);
    }
  }



  /**
   * Returns an XML-encoded representation of this, suitable for
   * submitting to the lab server for execution (or saving on the
   * service broker for subsequent retrieval).
   *
   * Note: if there is currently no device associated with this,
   * toXMLString will simply omit the deviceID tag from its output.
   */
  public final String toXMLString()
  {
    // start with an empty buffer
    StringBuffer sb = new StringBuffer();

    // write XML declaration
    sb.append
      ("<?xml version=\"1.0\" encoding=\"utf-8\" standalone=\"no\" ?>");

    // write document type declaration, if a DTD URL has been set
    if (dtdURL != null)
      sb.append
	("\n<!DOCTYPE experimentSpecification SYSTEM \"" + dtdURL + "\">");

    // write XML tags using a helper Visitor object
    this.accept(new ToXMLVisitor(sb));

    return sb.toString();
  }



  // helper method for parseXMLExperimentSpecification
  private static SourceFunction readXMLSourceFunction(Element xmlFunction)
    throws InvalidExperimentSpecificationException, InvalidXMLException,
	   NumberFormatException
  {
    // read <function type='X'> ...
    String typeName = xmlFunction.getRequiredAttributeValue("type");

    if (typeName.equals("CONS"))
    {
      // read <value>N</value>
      BigDecimal value = EngMath.parseBigDecimal
	(xmlFunction.getRequiredChild("value").getRequiredData());

      // ... </function>
      return new CONSFunction(value);
    }
    else if (typeName.equals("VAR1"))
    {
      // read <scale>X</scale>
      int scale;
      String scaleName =
	xmlFunction.getRequiredChild("scale").getRequiredData();
      if (scaleName.equals("LIN"))
	scale = VAR1Function.LIN_SCALE;
      else if (scaleName.equals("LOG10"))
	scale = VAR1Function.LOG10_SCALE;
      else if (scaleName.equals("LOG25"))
	scale = VAR1Function.LOG25_SCALE;
      else if (scaleName.equals("LOG50"))
	scale = VAR1Function.LOG50_SCALE;
      else {
	throw new InvalidExperimentSpecificationException
	  ("illegal scale: " + scaleName);
      }

      // read <start>N</start>
      BigDecimal start = EngMath.parseBigDecimal
	(xmlFunction.getRequiredChild("start").getRequiredData());

      // read <stop>N</stop>
      BigDecimal stop = EngMath.parseBigDecimal
	(xmlFunction.getRequiredChild("stop").getRequiredData());

      // read <step>N</step> (LIN scale only)
      BigDecimal step;
      if (scale == VAR1Function.LIN_SCALE)
	step = EngMath.parseBigDecimal
	  (xmlFunction.getRequiredChild("step").getRequiredData());
      else
	step = null;

      // ... </function>
      return new VAR1Function(scale, start, stop, step);      
    }
    else if (typeName.equals("VAR2"))
    {
      // read <start>N</start>
      BigDecimal start = EngMath.parseBigDecimal
	(xmlFunction.getRequiredChild("start").getRequiredData());

      // read <stop>N</stop>
      BigDecimal stop = EngMath.parseBigDecimal
	(xmlFunction.getRequiredChild("stop").getRequiredData());

      // read <step>N</step>
      BigDecimal step = EngMath.parseBigDecimal
	(xmlFunction.getRequiredChild("step").getRequiredData());

      // ... </function>
      return new VAR2Function(start, stop, step);
    }
    else if (typeName.equals("VAR1P"))
    {
      // read <ratio>N</ratio>
      BigDecimal ratio = EngMath.parseBigDecimal
	(xmlFunction.getRequiredChild("ratio").getRequiredData());

      // read <offset>N</offset>
      BigDecimal offset = EngMath.parseBigDecimal
	(xmlFunction.getRequiredChild("offset").getRequiredData());

      // ... </function>
      return new VAR1PFunction(ratio, offset);
    }
    else {
      throw new InvalidExperimentSpecificationException
	("illegal source function type: " + typeName);
    }
  }



  // helper class for toXMLString
  private static class ToXMLVisitor extends DefaultVisitor
  {
    // StringBuffer to write XML into
    private StringBuffer sb;

    public ToXMLVisitor(StringBuffer sb)
    {
      this.sb = sb;
    }

    public final void visitExperimentSpecification(ExperimentSpecification e)
    {
      // begin experimentSpecification
      sb.append("<experimentSpecification " +
		"lab=\"MIT Microelectronics Weblab\" specversion=\"0.1\">");

      // deviceID (if any)
      if (e.getDevice() != null)
      {
	sb.append("<deviceID>" + e.getDevice().getDeviceID() + "</deviceID>");
      }

      // visit Ports
      for (Iterator i = e.getPorts(); i.hasNext(); )
      {
	Port nextPort = (Port) i.next();
	nextPort.accept(this);
      }

      // visit UDFs
      for (Iterator i = e.getUserDefinedFunctions(); i.hasNext(); )
      {
	UserDefinedFunction udf = (UserDefinedFunction) i.next();
	udf.accept(this);
      }

      // end experimentSpecification
      sb.append("</experimentSpecification>");
    }

    public final void visitSMU(SMU u)
    {
      // begin terminal
      sb.append("<terminal portType=\"SMU\" portNumber=\"");
      sb.append(u.getNumber());
      sb.append("\">");

      // vname
      if (u.getVDownload())
	sb.append("<vname download=\"true\">");
      else
	sb.append("<vname download=\"false\">");
      sb.append(u.getVName());
      sb.append("</vname>");

      // iname
      if (u.getIDownload())
	sb.append("<iname download=\"true\">");
      else
	sb.append("<iname download=\"false\">");
      sb.append(u.getIName());
      sb.append("</iname>");

      // the rest depends on mode:
      switch (u.getMode())
      {
      case SMU.COMM_MODE:
	// COMM mode just has mode, nothing else
	sb.append("<mode>COMM</mode>");
	break;
      case SMU.V_MODE:
	// V mode has mode, function, and compliance
	sb.append("<mode>V</mode>");
	// function
	u.getFunction().accept(this);
	// compliance
	sb.append("<compliance>");
	sb.append(u.getCompliance());
	sb.append("</compliance>");
	break;
      case SMU.I_MODE:
	// I mode has mode, function, and compliance
	sb.append("<mode>I</mode>");
	// function
	u.getFunction().accept(this);
	// compliance
	sb.append("<compliance>");
	sb.append(u.getCompliance());
	sb.append("</compliance>");
	break;
      }

      // end terminal
      sb.append("</terminal>");
    }

    public final void visitVMU(VMU u)
    {
      // begin terminal
      sb.append("<terminal portType=\"VMU\" portNumber=\"");
      sb.append(u.getNumber());
      sb.append("\">");

      // vname
      if (u.getVDownload())
	sb.append("<vname download=\"true\">");
      else
	sb.append("<vname download=\"false\">");
      sb.append(u.getVName());
      sb.append("</vname>");

      // currently weblab only supports V mode for VMUs   
      switch (u.getMode())
      {
      case VMU.V_MODE:
	// V mode for VMUs just has mode, nothing else
	sb.append("<mode>V</mode>");
	break;
      }

      // end terminal
      sb.append("</terminal>");
    }

    public final void visitVSU(VSU u)
    {
      // begin terminal
      sb.append("<terminal portType=\"VSU\" portNumber=\"");
      sb.append(u.getNumber());
      sb.append("\">");

      // vname
      if (u.getVDownload())
	sb.append("<vname download=\"true\">");
      else
	sb.append("<vname download=\"false\">");
      sb.append(u.getVName());
      sb.append("</vname>");

      // function
      u.getFunction().accept(this);

      // end terminal
      sb.append("</terminal>");
    }

    public final void visitCONSFunction(CONSFunction f)
    {
      sb.append("<function type=\"CONS\">");

      sb.append("<value>");
      sb.append(f.getValue());
      sb.append("</value>");

      sb.append("</function>");
    }

    public final void visitVAR1Function(VAR1Function f)
    {
      sb.append("<function type=\"VAR1\">");

      switch(f.getScale())
      {
      case VAR1Function.LIN_SCALE:
	sb.append("<scale>LIN</scale>");
	break;
      case VAR1Function.LOG10_SCALE:
	sb.append("<scale>LOG10</scale>");
	break;
      case VAR1Function.LOG25_SCALE:
	sb.append("<scale>LOG25</scale>");
	break;
      case VAR1Function.LOG50_SCALE:
	sb.append("<scale>LOG50</scale>");
	break;
      }

      sb.append("<start>");
      sb.append(f.getStart());
      sb.append("</start>");

      sb.append("<stop>");
      sb.append(f.getStop());
      sb.append("</stop>");

      if (f.getScale() == VAR1Function.LIN_SCALE)
      {
	sb.append("<step>");
	sb.append(f.getStep());
	sb.append("</step>");
      }

      sb.append("</function>");
    }

    public final void visitVAR2Function(VAR2Function f)
    {
      sb.append("<function type=\"VAR2\">");

      // always LIN scale
      sb.append("<scale>LIN</scale>");

      sb.append("<start>");
      sb.append(f.getStart());
      sb.append("</start>");

      sb.append("<stop>");
      sb.append(f.getStop());
      sb.append("</stop>");

      sb.append("<step>");
      sb.append(f.getStep());
      sb.append("</step>");

      sb.append("</function>");
    }

    public final void visitVAR1PFunction(VAR1PFunction f)
    {
      sb.append("<function type=\"VAR1P\">");

      sb.append("<ratio>");
      sb.append(f.getRatio());
      sb.append("</ratio>");

      sb.append("<offset>");
      sb.append(f.getOffset());
      sb.append("</offset>");

      sb.append("</function>");
    }

    public final void visitUserDefinedFunction(UserDefinedFunction udf)
    {
      // begin userDefinedFunction
      sb.append("<userDefinedFunction>");

      // name
      if (udf.getDownload())
	sb.append("<name download=\"true\">");
      else
	sb.append("<name download=\"false\">");
      sb.append(udf.getName());
      sb.append("</name>");

      // units
      sb.append("<units>");
      sb.append(udf.getUnits());
      sb.append("</units>");

      // body
      sb.append("<body>");
      sb.append(udf.getBody());
      sb.append("</body>");

      // end userDefinedFunction
      sb.append("</userDefinedFunction>");    
    }
  } // end inner class ToXMLVisitor



  /**
   * Accepts a Visitor, according to the Visitor design pattern.
   */
  public final void accept(Visitor v)
  {
    v.visitExperimentSpecification(this);
  }



  public Object clone()
  {
    try
    {
      ExperimentSpecification clone = (ExperimentSpecification) super.clone();
      clone.deleteObservers();

      clone.udfs = (ArrayList) udfs.clone();
      clone.ports = new ArrayList();
      for (Iterator i = ports.iterator(); i.hasNext(); )
      {
	clone.ports.add(((Port) i.next()).clone());
      }
      return clone;
    }
    catch (CloneNotSupportedException ex)
    {
      throw new Error(ex);
    }
  }



  // helper function to find the index of a UDF with the specified name
  private int indexOfUDF(String name)
  {
    for (int i = 0, n = udfs.size(); i < n; i++)
    {
      UserDefinedFunction u = (UserDefinedFunction) udfs.get(i);
      if (u.getName().equals(name))
	return i;
    }

    return -1;
  }

} // end class ExperimentSpecification
